ractipのmainから順番にソースを読んでいこう。

parse_optionsでパースしてractipクラスにデータを格納した。
::このRactIPクラスの中のリード相当メンバをアラインメントに変える。

string fa1_
string fa2_
の型を
Alnに変更する。##
変更しない。これはファイル名。その後ロードする場面があるので、そこの行き先を変更する。

Alnの実装はaln.hに入っているのでinclude.

args_info.inputs[0]とは
gengetopt_args_info args_info

Aln::loadが使えるようだ。

loadしたので、次は処理の部分を入れる。

loadまで完了した。
solve関数の中の書き換えを行う。

solveの中、//calculate posterior probability matrices以下を書き換えかと思われる。

contrafold()がcontrafoldを使ったbasepair probability matrixの計算関数だと思われる。

ここについて、自前のcentroidalifoldを利用する関数ですり替える。

まず入力と出力（ここではどのようにbpmatrixをRactIPが格納しているか)について
調べる。
次に、その間をどう埋めるかについて、
centroidalifoldの実装を参考にして決めて書きましょう。




:::::
alifold::入力について
入力は(const std::string&seq, VF& bp, VI& offset, VVF& up) const
"インターフェースがあったらやりやすかったのにな"

VF, VVF, VIの定義
typedef std::vector<float> VF;
typedef std::vector<VF> VVF;
typedef std::vector<int>VI
typedef std::vector<VI> VVI;

返り値、というか実行結果の格納はこれらbp,offset,upに対して行う。
問題は、bp,offset,upが本当に予想しているようなものか、すなわち

SStruct SequenceStruct
ParameterManager parameter set
InferenceEngine iroiro, contrafoldの核

contrafold()の読解
string& seq, VF& bp, VI& offset, VVF& up
seqに変更なし

(参照：エイリアス（ポインタ非依存）)
GetPosterior(0,bp,offset)で
GetPosterior(0,bp){
bp.resize(SIZE);
for (int i=0; i<SIZE; i++){
    bp[i]=(posterior[i] >= posterior_cutoff ? posterior[i] : RealT(0));
}
offsetにこのクラス(InferenceEngine)のoffsetが上書きされる



up


実装だが、centroidalifoldで行われていた、呼び出されていたとおりに
入れればいいと思う。


centroidalifold.cppでの呼びだされかたに注目。



--------------------------------------------
作業ログ：
parserの形が違うのね。
centroid_alifoldで用いられてるBoost式のinput方法か
ractIPのgengetopt式の入力方法か
どっちがいいに統一して書き直す。
ractIP式の方が有利か。gengetoptのパーサの編集方法をみて、採用しよう。
あと、centroidalifoldの論文をよく読んで、必要なパラメータが何かをみよう。
ちゃんとコードを読むことにした。

アラインメントにおける塩基対確率を求める確率モデルにおいて
必要な、与えられるパラメータを以下にリストアップする。

A: Alignment
n: the number of sequences in A
(どのestimatorを用いるか(McCaskill, CONTRAfold)
w: mixture modelの混合重み

InputはractIP流にすることにする。
(のちのちのバグのことを考えたら、追加していく方が楽と考えた。）


gengetoptを使ったみたい。
gengetoptファイルはの残ってないので、めんどくさい。
cmdline.hに手動で追加できるかやってみよう。
やめた方がよさそう。(長いコードなので、読むのに時間がかかるし、変えたときに何がおこるか予想しにくい)
新しい.ggoファイルを作成する必要がある。
なるべく現在のものと互換性を持たせるようにする。
gengetoptに対する呼び出し部分から、順番に.ggoファイルを作成する。

ractipに引数を与えなかったときの出力が参考になるかもしれない。

-----------------------
その実装が終わった後
（構文解析が終了した後）

centroid_alifoldの流れ：
(自分でかいた方が早いかもしれないが、もう少し粘ってみよう)
パラメータのオプションを解析して、順番にその結果を格納している。
同様にractIPの中でも格納を行う。

ractIPのアルゴリズムをこのあとにつかうことを考慮すると、
コードを完全に読んでいない以上、
ractIPのcontraFold関数とほぼ同じ形式にするべきと考える。
Alignmentの情報は、塩基対確率を与えた時点で消去される。
塩基対確率には二種類あって、
RNA自己での塩基対確率と、
相互のRNA間での塩基対確率がある。

ractIPではその二つが計算されているはずである。（centroid_alifoldでは計算されてないはず）
まず、前者に集中する。
<watching: centroid_alifold.cpp>
push_backは単なるVectorのメンバ関数であって、DPmatrixのpushbackという意味ではない。
(ちなみに、centroid_alifoldはInside-Outside アルゴリズムを使っている)
engine.size
engine：std::vector<std::string>
(まずはcontrafoldだけでいい)
    ("engine,e", po::value<std::vector<std::string> >(&engine),
     "specify the inference engine (default: \"CONTRAfold\")")
    engine.push_back("CONTRAfold");
    なんでengineが複数必要なのか：
    二つのモデルの混合で塩基対確率としている。
    指定されなかった場合とかも考えて、
    engineはベクターとして用意されている。

vm.count:  po::variables_map vm;

modelsに順番にcf_list[i]とmix_w[i]をペアにして格納している。
mix_w[i]の由来：("mixture,w", po::value<std::vector<float> >(&mix_w), "mixture weights of inference engines")//poはコマンド引数を受け取るためのオプション、今回は違う方法で受け取るので理解しなくてよい

cf_listの由来:  std::vector<FoldingEngine<Aln>*> cf_list(engine.size(), NULL);
std::vector<FoldingEngine<Aln>*> cf_list(engine.size(), NULL);
      cf_list[i] = new AveragedModel(src_list[i], max_bp_dist, vm.count("mea"));
      cf_list[i] = new CONTRAfoldMultiModel(param, !vm.count("noncanonical"), max_bp_dist, seed, vm.count("mea"));
      cf_list[i] = new AveragedModel(src_list[i], max_bp_dist, vm.count("mea"));
      cf_list[i] = new AliFoldModel(!vm.count("noncanonical"), max_bp_dist,//これだけでいい
      cf_list[i] = new PfoldModel<Aln>(pfold_bin_dir, awk_bin, sed_bin, vm.count("mea"));
      cf_list[i] = new AveragedModel(src_list[i], 0, vm.count("mea"));
    cf=cf_list[0];
        models.push_back(std::make_pair(cf_list[i], 1.0)e);
        models.push_back(std::make_pair(cf_list[i], mix_w[i]));
  for (uint i=0; i!=cf_list.size(); ++i) if (cf_list[i]) delete cf_list[i];

namespace po = boost::progrpam_options;

MixtureModel<Aln>(models,vm.count("mea"))の内装
やはりcentroid_alifoldとractIPをインストールした方が良さそうだ
（入力、出力）
インストールできた。作業復帰。実装するぞ。


MixtureModel<Alb>の内装を細かく知る必要はないのではないか。（短ければ読んどいた方がいい）
Basepair probabilityの引き出し方さえわかればよい。

実装開始。
1.MixtureModel<Aln>(models,vm.count("mea"))
に投げる引数を用意するところまでを実装する。
gamma:関係ない(Nussinovアルゴリズムの時に使う)

modelsの中の計算だけ抜き出すのでもよい。

何かしらのBPTableを抜き出す -> ractIPにフィットするように変換 -> ractIPに向けて返す
の3ステップで実装する。

最初のステップ、コマンドラインのポインタをそのまま渡して内部で処理してもらう方が実装が楽な気がしてきた。
しかしそれは不可能。gengetoptに渡すことができない。

やはりなんとしても最初の入出力を完成させなければ先にすすめない。

/model*4
/Alignment*2
/mix_w*2

まず現在のコードに合うようにggoファイルを作成して、そこに
alignment用のコードを挿入する。


ちなみに現在のractipが出力するヘルプはこれ。


  -h, --help                 Print help and exit
      --full-help            Print help, including hidden options, and exit
  -V, --version              Print version and exit
  -a, --alpha=FLOAT          weight for hybridization  (default=`0.5')
  -b, --beta=FLOAT           weight for unpaired bases  (default=`0.0')
  -t, --fold-th=FLOAT        Threshold for base-pairing probabilities  
                               (default=`0.5')
  -u, --hybridize-th=FLOAT   Threshold for hybridazation probabilities  
                               (default=`0.2')
  -s, --acc-th=FLOAT         Threshold for accessible probabilities  
                               (default=`0.0')
      --max-w=INT            Maximum length of accessible regions  
                               (default=`0')
      --min-w=INT            Minimum length of accessible regions  
                               (default=`0')
      --zscore=INT           Calculate z-score via dishuffling (0=no shuffling, 
                               1=1st seq only, 2=2nd seq only, or 12=both)  
                               (default=`0')
      --num-shuffling=INT    The number of shuffling  (default=`1000')
      --seed=INT             Seed for random number generator  (default=`0')
  -m, --mccaskill            Use McCaskill model for folding  (default=off)
  -i, --allow-isolated       Allow isolated base-pairs  (default=off)
  -e, --show-energy          calculate the free energy of the predicted joint 
                               structure  (default=off)
  -P, --param-file=FILENAME  Read the energy parameter file for Vienna RNA 
                               package
  -p, --no-pk                do not use the constraints for interenal 
                               pseudoknots  (default=off)
  -r, --rip=FILENAME         Import posterior probabilities from the result of 
                               RIP

これRIPファイルで入力させればいいんじゃない・・・？
centroidalifoldの前半部分だけを切り取って結果として出力して、
二つをpythonで結べばいい気がしてきた。
load_from_rinに注目。
< ripはまったく違った。まともにやろう。
