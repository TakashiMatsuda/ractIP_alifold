ractipのmainから順番にソースを読んでいこう。

parse_optionsでパースしてractipクラスにデータを格納した。
::このRactIPクラスの中のリード相当メンバをアラインメントに変える。

string fa1_
string fa2_
の型を
Alnに変更する。##
変更しない。これはファイル名。その後ロードする場面があるので、そこの行き先を変更する。

Alnの実装はaln.hに入っているのでinclude.

args_info.inputs[0]とは
gengetopt_args_info args_info

Aln::loadが使えるようだ。

loadしたので、次は処理の部分を入れる。

loadまで完了した。
solve関数の中の書き換えを行う。

solveの中、//calculate posterior probability matrices以下を書き換えかと思われる。

contrafold()がcontrafoldを使ったbasepair probability matrixの計算関数だと思われる。

ここについて、自前のcentroidalifoldを利用する関数ですり替える。

まず入力と出力（ここではどのようにbpmatrixをRactIPが格納しているか)について
調べる。
次に、その間をどう埋めるかについて、
centroidalifoldの実装を参考にして決めて書きましょう。




:::::
alifold::入力について
入力は(const std::string&seq, VF& bp, VI& offset, VVF& up) const
"インターフェースがあったらやりやすかったのにな"

VF, VVF, VIの定義
typedef std::vector<float> VF;
typedef std::vector<VF> VVF;
typedef std::vector<int>VI
typedef std::vector<VI> VVI;

返り値、というか実行結果の格納はこれらbp,offset,upに対して行う。
問題は、bp,offset,upが本当に予想しているようなものか、すなわち

SStruct SequenceStruct
ParameterManager parameter set
InferenceEngine iroiro, contrafoldの核

contrafold()の読解
string& seq, VF& bp, VI& offset, VVF& up
seqに変更なし

(参照：エイリアス（ポインタ非依存）)
GetPosterior(0,bp,offset)で
GetPosterior(0,bp){
bp.resize(SIZE);
for (int i=0; i<SIZE; i++){
    bp[i]=(posterior[i] >= posterior_cutoff ? posterior[i] : RealT(0));
}
offsetにこのクラス(InferenceEngine)のoffsetが上書きされる



up


実装だが、centroidalifoldで行われていた、呼び出されていたとおりに
入れればいいと思う。


centroidalifold.cppでの呼びだされかたに注目。



--------------------------------------------
作業ログ：
parserの形が違うのね。
centroid_alifoldで用いられてるBoost式のinput方法か
ractIPのgengetopt式の入力方法か
どっちがいいに統一して書き直す。
ractIP式の方が有利か。gengetoptのパーサの編集方法をみて、採用しよう。
あと、centroidalifoldの論文をよく読んで、必要なパラメータが何かをみよう。
ちゃんとコードを読むことにした。

アラインメントにおける塩基対確率を求める確率モデルにおいて
必要な、与えられるパラメータを以下にリストアップする。

A: Alignment
n: the number of sequences in A
(どのestimatorを用いるか(McCaskill, CONTRAfold)
w: mixture modelの混合重み

InputはractIP流にすることにする。
(のちのちのバグのことを考えたら、追加していく方が楽と考えた。）


gengetoptを使ったみたい。
gengetoptファイルはの残ってないので、めんどくさい。
cmdline.hに手動で追加できるかやってみよう。
やめた方がよさそう。(長いコードなので、読むのに時間がかかるし、変えたときに何がおこるか予想しにくい)
新しい.ggoファイルを作成する必要がある。
なるべく現在のものと互換性を持たせるようにする。
gengetoptに対する呼び出し部分から、順番に.ggoファイルを作成する。

ractipに引数を与えなかったときの出力が参考になるかもしれない。

-----------------------
その実装が終わった後
（構文解析が終了した後）

centroid_alifoldの流れ：
(自分でかいた方が早いかもしれないが、もう少し粘ってみよう)
パラメータのオプションを解析して、順番にその結果を格納している。
同様にractIPの中でも格納を行う。

ractIPのアルゴリズムをこのあとにつかうことを考慮すると、
コードを完全に読んでいない以上、
ractIPのcontraFold関数とほぼ同じ形式にするべきと考える。
Alignmentの情報は、塩基対確率を与えた時点で消去される。
塩基対確率には二種類あって、
RNA自己での塩基対確率と、
相互のRNA間での塩基対確率がある。

ractIPではその二つが計算されているはずである。（centroid_alifoldでは計算されてないはず）
まず、前者に集中する。
<watching: centroid_alifold.cpp>
push_backは単なるVectorのメンバ関数であって、DPmatrixのpushbackという意味ではない。
(ちなみに、centroid_alifoldはInside-Outside アルゴリズムを使っている)
engine.size
engine：std::vector<std::string>
(まずはcontrafoldだけでいい)
    ("engine,e", po::value<std::vector<std::string> >(&engine),
     "specify the inference engine (default: \"CONTRAfold\")")
    engine.push_back("CONTRAfold");
    なんでengineが複数必要なのか：
    二つのモデルの混合で塩基対確率としている。
    指定されなかった場合とかも考えて、
    engineはベクターとして用意されている。

vm.count:  po::variables_map vm;

modelsに順番にcf_list[i]とmix_w[i]をペアにして格納している。
mix_w[i]の由来：("mixture,w", po::value<std::vector<float> >(&mix_w), "mixture weights of inference engines")//poはコマンド引数を受け取るためのオプション、今回は違う方法で受け取るので理解しなくてよい

cf_listの由来:  std::vector<FoldingEngine<Aln>*> cf_list(engine.size(), NULL);
std::vector<FoldingEngine<Aln>*> cf_list(engine.size(), NULL);
      cf_list[i] = new AveragedModel(src_list[i], max_bp_dist, vm.count("mea"));
      cf_list[i] = new CONTRAfoldMultiModel(param, !vm.count("noncanonical"), max_bp_dist, seed, vm.count("mea"));
      cf_list[i] = new AveragedModel(src_list[i], max_bp_dist, vm.count("mea"));
      cf_list[i] = new AliFoldModel(!vm.count("noncanonical"), max_bp_dist,//これだけでいい
      cf_list[i] = new PfoldModel<Aln>(pfold_bin_dir, awk_bin, sed_bin, vm.count("mea"));
      cf_list[i] = new AveragedModel(src_list[i], 0, vm.count("mea"));
    cf=cf_list[0];
        models.push_back(std::make_pair(cf_list[i], 1.0)e);
        models.push_back(std::make_pair(cf_list[i], mix_w[i]));
  for (uint i=0; i!=cf_list.size(); ++i) if (cf_list[i]) delete cf_list[i];

namespace po = boost::progrpam_options;

MixtureModel<Aln>(models,vm.count("mea"))の内装
やはりcentroid_alifoldとractIPをインストールした方が良さそうだ
（入力、出力）
インストールできた。作業復帰。実装するぞ。


MixtureModel<Alb>の内装を細かく知る必要はないのではないか。（短ければ読んどいた方がいい）
Basepair probabilityの引き出し方さえわかればよい。

実装開始。
1.MixtureModel<Aln>(models,vm.count("mea"))
に投げる引数を用意するところまでを実装する。
gamma:関係ない(Nussinovアルゴリズムの時に使う)

modelsの中の計算だけ抜き出すのでもよい。

何かしらのBPTableを抜き出す -> ractIPにフィットするように変換 -> ractIPに向けて返す
の3ステップで実装する。

最初のステップ、コマンドラインのポインタをそのまま渡して内部で処理してもらう方が実装が楽な気がしてきた。
しかしそれは不可能。gengetoptに渡すことができない。

やはりなんとしても最初の入出力を完成させなければ先にすすめない。

/model*4
/Alignment*2
/mix_w*2

まず現在のコードに合うようにggoファイルを作成して、そこに
alignment用のコードを挿入する。


ちなみに現在のractipが出力するヘルプはこれ。


  -h, --help                 Print help and exit
      --full-help            Print help, including hidden options, and exit
  -V, --version              Print version and exit
  -a, --alpha=FLOAT          weight for hybridization  (default=`0.5')
  -b, --beta=FLOAT           weight for unpaired bases  (default=`0.0')
  -t, --fold-th=FLOAT        Threshold for base-pairing probabilities  
                               (default=`0.5')
  -u, --hybridize-th=FLOAT   Threshold for hybridazation probabilities  
                               (default=`0.2')
  -s, --acc-th=FLOAT         Threshold for accessible probabilities  
                               (default=`0.0')
      --max-w=INT            Maximum length of accessible regions  
                               (default=`0')
      --min-w=INT            Minimum length of accessible regions  
                               (default=`0')
      --zscore=INT           Calculate z-score via dishuffling (0=no shuffling, 
                               1=1st seq only, 2=2nd seq only, or 12=both)  
                               (default=`0')
      --num-shuffling=INT    The number of shuffling  (default=`1000')
      --seed=INT             Seed for random number generator  (default=`0')
  -m, --mccaskill            Use McCaskill model for folding  (default=off)
  -i, --allow-isolated       Allow isolated base-pairs  (default=off)
  -e, --show-energy          calculate the free energy of the predicted joint 
                               structure  (default=off)
  -P, --param-file=FILENAME  Read the energy parameter file for Vienna RNA 
                               package
  -p, --no-pk                do not use the constraints for interenal 
                               pseudoknots  (default=off)
  -r, --rip=FILENAME         Import posterior probabilities from the result of 
                               RIP

これRIPファイルで入力させればいいんじゃない・・・？
centroidalifoldの前半部分だけを切り取って結果として出力して、
二つをpythonで結べばいい気がしてきた。
load_from_ripに注目。
< ripはまったく違った。まともにやろう。

cmdlineを作り終えた。
次はファイルポインタの受け渡し。どのように行うか。

If you specify the inference engines multiply, centroid_alifold employs a mixtured baes-pairing probability matrix. The mixture weight can be set by '-w' or '--mixture' option. The default setting of centroid_alifold is '-e McCaskill -w 1.0 -e Alifold -w 1.0'. See more detail in (Hamada et al., 2010).

上の意味がわからない。二つの方法のweightがどちらも1.0とはどういうことなんだろうか。
論文を参照。
論文では0.5,0.5の配分と書いてあることから、あとで半分にしているのだろうか。内装をみてみる。
（今回はcentroidalifoldにしたがう必要がある）

ファイルポインタの引き渡し部分を実装する。
ファイルのパスを引き渡した。

受け取り側の型がconst char*
もとの型はstring
この二つの間に互換性はあるか。
安全性からload関数の方の受け取り型をstringに変えることができないだろうか。

Aln::loadの内装をみている。
file_iterator: boost/spirit/include/classic.hppにあるらしい
あとは内装をみる必要はなさそうだ。
faとalnは非常によくにて作られている、作者も同じ人だしfaを流用してalnを作ったのだろう。

centroid_alifold section, つまり
alignmentに対する塩基対確率の計算に必要なパラメータを用意してまとめて適切な形でsolve関数に渡す。

modelsに渡すもの
engine
どのようにengineを収集していたか、に着目。
たくさん書いてあって、最終的にはgammaに関する記述部分をのぞく部分をすべてractIPに搭載することに
なると思う。
理解したところから順番にソースに加えていく。
とりあえずデフォルトのみをカバーするコードを書く。

po::variables_map vmとは何だろう
variables_map: オプション引数を格納したmap
vm.countで、辞書的に指定したオプション引数を取り出すことができる。

vm.countとなっているところを修正して、投げる。
meaとか関係ない。
これリファクタリングしたほうがいいな。

投げるところまでできた。

base-pairing probabilityを取り出すメンバ関数をつくるか、
centroid_alifoldで用いられている方法をそのまま流用して、
塩基対確率行列を得る。

MixtureModelのコンストラクタに塩基対確率行列の作成が実装されているかもしれない
中をみていて、意味をしらない文法が出てきた。したにメモしておく。
// Reading
template <class SEQ>
MixtureModel<SEQ>::
MixtureModel(const std::vector<std::pair<FoldingEngine<SEQ>*,float> >& models,
             bool run_as_mea /*=false*/)
  : FoldingEngine<SEQ>(run_as_mea, 0), models_(models)
{
}
コロンのつづきは初期化を表すということ（らしい）、標準は読んでません
順番にみていく。
FoldingEngineの初期化、おそらくこれは関係ないと思う。（modelsを入れていないので）
変数名が書いてないのは何故
models_の初期化：
std::vector<std::pair<FoldingEngine<SEQ>*,float> > models_;
これを初期化してもとくに何もおこらない、メンバに代入するだけ
なにもしていない。

次を読む。どこで塩基対確率が代入されているかを読みつづける。
calculate_posteriarで実装されている（みたい）


そのままcontrafoldと同様に実装していいんじゃないかな。
継承のことも考えると、
FoldingEngineとInferenceEngineの違いが気になる。
FoldingEngineもInferenceEngineも何も継承していないクラスだった。
umu.
FoldingEngineの内装を読んでいって、どこで塩基対確率を求めているか理解する。
最終的にはcontrafoldとかを使うはずだから、そこに注目すればわかりやすいかもしれない。
FoldingEngineの内装を読み始める前に、
centroid_alifoldの、cfが作られたあとのその利用状況について理解するのも必要だと思う。
cf->stochastic_fold:
FoldingEngineの実装。

calculate_posterior:
x->first firstはpairの第一要素
FoldingEngine::calculate_posterior(SEQ seq):
  virtual void calculate_posterior(const SEQ& seq) = 0;
virtual宣言:仮想宣言
実装は継承したクラス内で行われ、そのクラス内では宣言のみ行うときに書く

これを呼び出せばいいのかな
結果はどこに保管されるのだろう
FoldingEngine:bp_
BPTable bp_
get_bp()で返ってくるみたい
  const BPTable& get_bp() const { return bp_; }

stochastic_fold内でcalculate_posteriorが呼び出されているか < 未確認
ractIP::alifoldの中でcalclulate_posterior(seq)とget_bp()を実装した
でも、offset変数にも何かを入れないとractIPは動作しないみたい


contrafold()でのoffsetの振る舞いをみる。
下の文を再現するには、どうすればいいのか。
  SStruct ss("unknown", seq);
  ParameterManager<float> pm;
  InferenceEngine<float> en(false);
  VF w = GetDefaultComplementaryValues<float>();
  bp.resize((seq.size()+1)*(seq.size()+2)/2);
  std::fill(bp.begin(), bp.end(), 0.0);
  en.RegisterParameters(pm);
  en.LoadValues(w);
  en.LoadSequence(ss);
  en.ComputeInside();
  en.ComputeOutside();
  en.ComputePosterior();
  en.GetPosterior(0, bp, offset);//



offset:
相殺、差し引き、埋め合わせ
分かれ出たもの
offset:(内装のなかでの意味)
InferenceEngine<float>::GetPosterior :
RealT *GetPosterior(const RealT posterior_cutoff, std::vector<RealT>& p, std::vector<int>& o) const
    {
        RealT* ret = GetPosterior(posterior_cutoff, p);
        o = offset;
        return ret;
    }// Reading


GetPosterior(0,bp,offset)で
GetPosterior(0,bp){
bp.resize(SIZE);
for (int i=0; i<SIZE; i++){
    bp[i]=(posterior[i] >= posterior_cutoff ? posterior[i] : RealT(0));
}
offsetにこのクラス(InferenceEngine)のoffsetが上書きされる
InferenceEngine::offsetがどこで編集されるか調べる
//C++のクラスのコード、toStringがないとデバッグも理解するのも難しいね。

offset:
headerには操作が見つからなかった
InferenceEngine.ipp
//////////////////////////////////////////////////////////////////////
// ComputeRowOffset()
//
// Consider an N x N upper triangular matrix whose elements are
// stored in a one-dimensional flat array using the following
// row-major indexing scheme:
//
//     0  1  2  3     <-- row 0
//        4  5  6     <-- row 1
//           7 [8]    <-- row 2
//              9     <-- row 3
//
// Assuming 0-based indexing, this function computes offset[i]
// for the ith row such that offset[i]+j is the index of the
// (i,j)th element of the upper triangular matrix in the flat
// array.
//
// For example, offset[2] = 5, so the (2,3)th element of the
// upper triangular matrix (marked in the picture above) can be 
// found at position offset[2]+3 = 5+3 = 8 in the flat array.
//////////////////////////////////////////////////////////////////////

(space)

    // compute indexing scheme for upper triangular arrays;
    // also allow each position to be unpaired by default, and
    // set the loss for each unpaired position to zero
    for (int i = 0; i <= L; i++)
    {
      offset[i] = ComputeRowOffset(i,L+1,max_bp_dist);//
        allow_unpaired_position[i] = 1;
        loss_unpaired_position[i] = RealT(0);
    }

この実装がどこで呼ばれているか調べる。
返されたoffsetが何を表すのか調べる。
論文にもこの単語が出ていないか調べる。
offset はbpを参照するためのものだった。
bpmatrixは1-dimension vectorとして表現している。これはメモリを節約する工夫である。
これからcentroid_alifoldのbpから、ractIPのメモリ節約型bp+offsetに変換する部分を実装する。


