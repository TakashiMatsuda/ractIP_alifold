ractipのmainから順番にソースを読んでいこう。

parse_optionsでパースしてractipクラスにデータを格納した。
::このRactIPクラスの中のリード相当メンバをアラインメントに変える。

string fa1_
string fa2_
の型を
Alnに変更する。##
変更しない。これはファイル名。その後ロードする場面があるので、そこの行き先を変更する。

Alnの実装はaln.hに入っているのでinclude.

args_info.inputs[0]とは
gengetopt_args_info args_info

Aln::loadが使えるようだ。

loadしたので、次は処理の部分を入れる。

loadまで完了した。
solve関数の中の書き換えを行う。

solveの中、//calculate posterior probability matrices以下を書き換えかと思われる。

contrafold()がcontrafoldを使ったbasepair probability matrixの計算関数だと思われる。

ここについて、自前のcentroidalifoldを利用する関数ですり替える。

まず入力と出力（ここではどのようにbpmatrixをRactIPが格納しているか)について
調べる。
次に、その間をどう埋めるかについて、
centroidalifoldの実装を参考にして決めて書きましょう。




:::::
alifold::入力について
入力は(const std::string&seq, VF& bp, VI& offset, VVF& up) const
"インターフェースがあったらやりやすかったのにな"

VF, VVF, VIの定義
typedef std::vector<float> VF;
typedef std::vector<VF> VVF;
typedef std::vector<int>VI
typedef std::vector<VI> VVI;

返り値、というか実行結果の格納はこれらbp,offset,upに対して行う。
問題は、bp,offset,upが本当に予想しているようなものか、すなわち

SStruct SequenceStruct
ParameterManager parameter set
InferenceEngine iroiro, contrafoldの核

contrafold()の読解
string& seq, VF& bp, VI& offset, VVF& up
seqに変更なし

(参照：エイリアス（ポインタ非依存）)
GetPosterior(0,bp,offset)で
GetPosterior(0,bp){
bp.resize(SIZE);
for (int i=0; i<SIZE; i++){
    bp[i]=(posterior[i] >= posterior_cutoff ? posterior[i] : RealT(0));
}
offsetにこのクラス(InferenceEngine)のoffsetが上書きされる



up


実装だが、centroidalifoldで行われていた、呼び出されていたとおりに
入れればいいと思う。


centroidalifold.cppでの呼びだされかたに注目。



--------------------------------------------
作業ログ：
parserの形が違うのね。
centroid_alifoldで用いられてるBoost式のinput方法か
ractIPのgengetopt式の入力方法か
どっちがいいに統一して書き直す。
ractIP式の方が有利か。gengetoptのパーサの編集方法をみて、採用しよう。
あと、centroidalifoldの論文をよく読んで、必要なパラメータが何かをみよう。
ちゃんとコードを読むことにした。

アラインメントにおける塩基対確率を求める確率モデルにおいて
必要な、与えられるパラメータを以下にリストアップする。

A: Alignment
n: the number of sequences in A
(どのestimatorを用いるか(McCaskill, CONTRAfold)
w: mixture modelの混合重み

InputはractIP流にすることにする。
(のちのちのバグのことを考えたら、追加していく方が楽と考えた。）


gengetoptを使ったみたい。
gengetoptファイルはの残ってないので、めんどくさい。
cmdline.hに手動で追加できるかやってみよう。
やめた方がよさそう。(長いコードなので、読むのに時間がかかるし、変えたときに何がおこるか予想しにくい)
新しい.ggoファイルを作成する必要がある。
なるべく現在のものと互換性を持たせるようにする。
gengetoptに対する呼び出し部分から、順番に.ggoファイルを作成する。

ractipに引数を与えなかったときの出力が参考になるかもしれない。

-----------------------
その実装が終わった後
（構文解析が終了した後）

centroid_alifoldの流れ：
(自分でかいた方が早いかもしれないが、もう少し粘ってみよう)
パラメータのオプションを解析して、順番にその結果を格納している。
同様にractIPの中でも格納を行う。

ractIPのアルゴリズムをこのあとにつかうことを考慮すると、
コードを完全に読んでいない以上、
ractIPのcontraFold関数とほぼ同じ形式にするべきと考える。
Alignmentの情報は、塩基対確率を与えた時点で消去される。
塩基対確率には二種類あって、
RNA自己での塩基対確率と、
相互のRNA間での塩基対確率がある。

ractIPではその二つが計算されているはずである。（centroid_alifoldでは計算されてないはず）
まず、前者に集中する。
<watching: centroid_alifold.cpp>
push_backは単なるVectorのメンバ関数であって、DPmatrixのpushbackという意味ではない。
(ちなみに、centroid_alifoldはInside-Outside アルゴリズムを使っている)
engine.size
engine：std::vector<std::string>
(まずはcontrafoldだけでいい)
    ("engine,e", po::value<std::vector<std::string> >(&engine),
     "specify the inference engine (default: \"CONTRAfold\")")
    engine.push_back("CONTRAfold");
    なんでengineが複数必要なのか：
    二つのモデルの混合で塩基対確率としている。
    指定されなかった場合とかも考えて、
    engineはベクターとして用意されている。

vm.count:  po::variables_map vm;

modelsに順番にcf_list[i]とmix_w[i]をペアにして格納している。
mix_w[i]の由来：("mixture,w", po::value<std::vector<float> >(&mix_w), "mixture weights of inference engines")//poはコマンド引数を受け取るためのオプション、今回は違う方法で受け取るので理解しなくてよい

cf_listの由来:  std::vector<FoldingEngine<Aln>*> cf_list(engine.size(), NULL);
std::vector<FoldingEngine<Aln>*> cf_list(engine.size(), NULL);
      cf_list[i] = new AveragedModel(src_list[i], max_bp_dist, vm.count("mea"));
      cf_list[i] = new CONTRAfoldMultiModel(param, !vm.count("noncanonical"), max_bp_dist, seed, vm.count("mea"));
      cf_list[i] = new AveragedModel(src_list[i], max_bp_dist, vm.count("mea"));
      cf_list[i] = new AliFoldModel(!vm.count("noncanonical"), max_bp_dist,//これだけでいい
      cf_list[i] = new PfoldModel<Aln>(pfold_bin_dir, awk_bin, sed_bin, vm.count("mea"));
      cf_list[i] = new AveragedModel(src_list[i], 0, vm.count("mea"));
    cf=cf_list[0];
        models.push_back(std::make_pair(cf_list[i], 1.0)e);
        models.push_back(std::make_pair(cf_list[i], mix_w[i]));
  for (uint i=0; i!=cf_list.size(); ++i) if (cf_list[i]) delete cf_list[i];

namespace po = boost::progrpam_options;

MixtureModel<Aln>(models,vm.count("mea"))の内装
やはりcentroid_alifoldとractIPをインストールした方が良さそうだ
（入力、出力）
インストールできた。作業復帰。実装するぞ。


MixtureModel<Alb>の内装を細かく知る必要はないのではないか。（短ければ読んどいた方がいい）
Basepair probabilityの引き出し方さえわかればよい。

実装開始。
1.MixtureModel<Aln>(models,vm.count("mea"))
に投げる引数を用意するところまでを実装する。
gamma:関係ない(Nussinovアルゴリズムの時に使う)

modelsの中の計算だけ抜き出すのでもよい。

何かしらのBPTableを抜き出す -> ractIPにフィットするように変換 -> ractIPに向けて返す
の3ステップで実装する。

最初のステップ、コマンドラインのポインタをそのまま渡して内部で処理してもらう方が実装が楽な気がしてきた。
しかしそれは不可能。gengetoptに渡すことができない。

やはりなんとしても最初の入出力を完成させなければ先にすすめない。

/model*4
/Alignment*2
/mix_w*2

まず現在のコードに合うようにggoファイルを作成して、そこに
alignment用のコードを挿入する。


ちなみに現在のractipが出力するヘルプはこれ。


  -h, --help                 Print help and exit
      --full-help            Print help, including hidden options, and exit
  -V, --version              Print version and exit
  -a, --alpha=FLOAT          weight for hybridization  (default=`0.5')
  -b, --beta=FLOAT           weight for unpaired bases  (default=`0.0')
  -t, --fold-th=FLOAT        Threshold for base-pairing probabilities  
                               (default=`0.5')
  -u, --hybridize-th=FLOAT   Threshold for hybridazation probabilities  
                               (default=`0.2')
  -s, --acc-th=FLOAT         Threshold for accessible probabilities  
                               (default=`0.0')
      --max-w=INT            Maximum length of accessible regions  
                               (default=`0')
      --min-w=INT            Minimum length of accessible regions  
                               (default=`0')
      --zscore=INT           Calculate z-score via dishuffling (0=no shuffling, 
                               1=1st seq only, 2=2nd seq only, or 12=both)  
                               (default=`0')
      --num-shuffling=INT    The number of shuffling  (default=`1000')
      --seed=INT             Seed for random number generator  (default=`0')
  -m, --mccaskill            Use McCaskill model for folding  (default=off)
  -i, --allow-isolated       Allow isolated base-pairs  (default=off)
  -e, --show-energy          calculate the free energy of the predicted joint 
                               structure  (default=off)
  -P, --param-file=FILENAME  Read the energy parameter file for Vienna RNA 
                               package
  -p, --no-pk                do not use the constraints for interenal 
                               pseudoknots  (default=off)
  -r, --rip=FILENAME         Import posterior probabilities from the result of 
                               RIP

これRIPファイルで入力させればいいんじゃない・・・？
centroidalifoldの前半部分だけを切り取って結果として出力して、
二つをpythonで結べばいい気がしてきた。
load_from_ripに注目。
< ripはまったく違った。まともにやろう。

cmdlineを作り終えた。
次はファイルポインタの受け渡し。どのように行うか。

If you specify the inference engines multiply, centroid_alifold employs a mixtured baes-pairing probability matrix. The mixture weight can be set by '-w' or '--mixture' option. The default setting of centroid_alifold is '-e McCaskill -w 1.0 -e Alifold -w 1.0'. See more detail in (Hamada et al., 2010).

上の意味がわからない。二つの方法のweightがどちらも1.0とはどういうことなんだろうか。
論文を参照。
論文では0.5,0.5の配分と書いてあることから、あとで半分にしているのだろうか。内装をみてみる。
（今回はcentroidalifoldにしたがう必要がある）

ファイルポインタの引き渡し部分を実装する。
ファイルのパスを引き渡した。

受け取り側の型がconst char*
もとの型はstring
この二つの間に互換性はあるか。
安全性からload関数の方の受け取り型をstringに変えることができないだろうか。

Aln::loadの内装をみている。
file_iterator: boost/spirit/include/classic.hppにあるらしい
あとは内装をみる必要はなさそうだ。
faとalnは非常によくにて作られている、作者も同じ人だしfaを流用してalnを作ったのだろう。

centroid_alifold section, つまり
alignmentに対する塩基対確率の計算に必要なパラメータを用意してまとめて適切な形でsolve関数に渡す。

modelsに渡すもの
engine
どのようにengineを収集していたか、に着目。
たくさん書いてあって、最終的にはgammaに関する記述部分をのぞく部分をすべてractIPに搭載することに
なると思う。
理解したところから順番にソースに加えていく。
とりあえずデフォルトのみをカバーするコードを書く。

po::variables_map vmとは何だろう
variables_map: オプション引数を格納したmap
vm.countで、辞書的に指定したオプション引数を取り出すことができる。

vm.countとなっているところを修正して、投げる。
meaとか関係ない。
これリファクタリングしたほうがいいな。

投げるところまでできた。

base-pairing probabilityを取り出すメンバ関数をつくるか、
centroid_alifoldで用いられている方法をそのまま流用して、
塩基対確率行列を得る。

MixtureModelのコンストラクタに塩基対確率行列の作成が実装されているかもしれない
中をみていて、意味をしらない文法が出てきた。したにメモしておく。
// Reading
template <class SEQ>
MixtureModel<SEQ>::
MixtureModel(const std::vector<std::pair<FoldingEngine<SEQ>*,float> >& models,
             bool run_as_mea /*=false*/)
  : FoldingEngine<SEQ>(run_as_mea, 0), models_(models)
{
}
コロンのつづきは初期化を表すということ（らしい）、標準は読んでません
順番にみていく。
FoldingEngineの初期化、おそらくこれは関係ないと思う。（modelsを入れていないので）
変数名が書いてないのは何故
models_の初期化：
std::vector<std::pair<FoldingEngine<SEQ>*,float> > models_;
これを初期化してもとくに何もおこらない、メンバに代入するだけ
なにもしていない。

次を読む。どこで塩基対確率が代入されているかを読みつづける。
calculate_posteriarで実装されている（みたい）


そのままcontrafoldと同様に実装していいんじゃないかな。
継承のことも考えると、
FoldingEngineとInferenceEngineの違いが気になる。
FoldingEngineもInferenceEngineも何も継承していないクラスだった。
umu.
FoldingEngineの内装を読んでいって、どこで塩基対確率を求めているか理解する。
最終的にはcontrafoldとかを使うはずだから、そこに注目すればわかりやすいかもしれない。
FoldingEngineの内装を読み始める前に、
centroid_alifoldの、cfが作られたあとのその利用状況について理解するのも必要だと思う。
cf->stochastic_fold:
FoldingEngineの実装。

calculate_posterior:
x->first firstはpairの第一要素
FoldingEngine::calculate_posterior(SEQ seq):
  virtual void calculate_posterior(const SEQ& seq) = 0;
virtual宣言:仮想宣言
実装は継承したクラス内で行われ、そのクラス内では宣言のみ行うときに書く

これを呼び出せばいいのかな
結果はどこに保管されるのだろう
FoldingEngine:bp_
BPTable bp_
get_bp()で返ってくるみたい
  const BPTable& get_bp() const { return bp_; }

注意！
bp_に何が格納されているかの確認をしていない！！！
MulAdd, Divの理解をする必要がある。

// C++, Java, その他プログラミング言語にいえることだけど
書いた関数に関して、その仕様が明示され、保証されていないと
結局内装を理解する手間がかかることになって、
労力を削減できない。無駄である。
契約プログラミングとかいうけど、プログラムの仕様証明は非常に重要な課題だな。

stochastic_fold内でcalculate_posteriorが呼び出されているか < 未確認
ractIP::alifoldの中でcalclulate_posterior(seq)とget_bp()を実装した
でも、offset変数にも何かを入れないとractIPは動作しないみたい


contrafold()でのoffsetの振る舞いをみる。
下の文を再現するには、どうすればいいのか。
  SStruct ss("unknown", seq);
  ParameterManager<float> pm;
  InferenceEngine<float> en(false);
  VF w = GetDefaultComplementaryValues<float>();
  bp.resize((seq.size()+1)*(seq.size()+2)/2);
  std::fill(bp.begin(), bp.end(), 0.0);
  en.RegisterParameters(pm);
  en.LoadValues(w);
  en.LoadSequence(ss);
  en.ComputeInside();
  en.ComputeOutside();
  en.ComputePosterior();
  en.GetPosterior(0, bp, offset);//



offset:
相殺、差し引き、埋め合わせ
分かれ出たもの
offset:(内装のなかでの意味)
InferenceEngine<float>::GetPosterior :
RealT *GetPosterior(const RealT posterior_cutoff, std::vector<RealT>& p, std::vector<int>& o) const
    {
        RealT* ret = GetPosterior(posterior_cutoff, p);
        o = offset;
        return ret;
    }// Reading


GetPosterior(0,bp,offset)で
GetPosterior(0,bp){
bp.resize(SIZE);
for (int i=0; i<SIZE; i++){
    bp[i]=(posterior[i] >= posterior_cutoff ? posterior[i] : RealT(0));
}
offsetにこのクラス(InferenceEngine)のoffsetが上書きされる
InferenceEngine::offsetがどこで編集されるか調べる
//C++のクラスのコード、toStringがないとデバッグも理解するのも難しいね。

offset:
headerには操作が見つからなかった
InferenceEngine.ipp
//////////////////////////////////////////////////////////////////////
// ComputeRowOffset()
//
// Consider an N x N upper triangular matrix whose elements are
// stored in a one-dimensional flat array using the following
// row-major indexing scheme:
//
//     0  1  2  3     <-- row 0
//        4  5  6     <-- row 1
//           7 [8]    <-- row 2
//              9     <-- row 3
//
// Assuming 0-based indexing, this function computes offset[i]
// for the ith row such that offset[i]+j is the index of the
// (i,j)th element of the upper triangular matrix in the flat
// array.
//
// For example, offset[2] = 5, so the (2,3)th element of the
// upper triangular matrix (marked in the picture above) can be 
// found at position offset[2]+3 = 5+3 = 8 in the flat array.
//////////////////////////////////////////////////////////////////////

(space)

    // compute indexing scheme for upper triangular arrays;
    // also allow each position to be unpaired by default, and
    // set the loss for each unpaired position to zero
    for (int i = 0; i <= L; i++)
    {
      offset[i] = ComputeRowOffset(i,L+1,max_bp_dist);//
        allow_unpaired_position[i] = 1;
        loss_unpaired_position[i] = RealT(0);
    }

この実装がどこで呼ばれているか調べる。
返されたoffsetが何を表すのか調べる。
論文にもこの単語が出ていないか調べる。
offset はbpを参照するためのものだった。
bpmatrixは1-dimension vectorとして表現している。これはメモリを節約する工夫である。
これからcentroid_alifoldのbpから、ractIPのメモリ節約型bp+offsetに変換する部分を実装する。

もとのbpの形式と、offset systemを理解して、変換を書く
const BPTable& get_bp() const { return bp_; }
もとのbpの形式:
BPTable bp_;
BPTable: 
typedef BPTableTmpl<float> BPTable;
BPTableTmpl<V>:
bp.hに書いてある

BPTableTmpl<float>を理解したら、運動しにいこう。


*        used for Cocke-Younger-Kasami (CYK) algorithm
CYK法（英: CYK algorithm）は、ある文字列が与えられた文脈自由文法で生成できるかを決め、生成できる場合の生成方法を求めるアルゴリズムである。CYK は Cocke-Younger-Kasami の略。文字列の構文解析手法として知られている。このアルゴリズムは一種の動的計画法である。
標準的なCYK法は、チョムスキー標準形で書かれた文脈自由文法で定義される言語を認識する。任意の文脈自由文法をチョムスキー標準形に書き換えるのはそれほど困難ではないので、CYK法は任意の文脈自由文法の認識に使うことができる。CYK法を拡張してチョムスキー標準形で書かれていない文脈自由文法を扱うようにすることも可能である。これにより性能は向上するが、アルゴリズムを理解することは難しくなる。

どこから手をつければいいんだ？
MulAdd, Div:(bp_の性質の理解)
MulAdd:
struct
コンストラクタ:引数でメンバを初期化する
inside_traverse:	
    inside_traverse(0, bp_.size()-1, ma);
cyktable.h
template <class Update>
void
inside_traverse(uint from, uint to, Update& update)
{
  // for each position
  for (uint j=from; j!=to+1; ++j) {
    update(j, j);// updateは関数?: MulAdd::bp_.update(i, j, bp_(i,j)+w_*t_(i,j));
    Div::void operator()(uint i, uint j) { bp_.update(i, j, bp_(i,j)/d_); }

    if (j==from) continue;
    
    // for each substring
    for (uint i=j-1; ; --i) {
      update(i, j);
      if (i==from) break;
    }
  }
}
void update(uint i, uint j, T v) { bp_(i,j)=v; }//
void operator()(uint i, uint j) { bp_.update(i, j, bp_(i,j)+w_*t_(i,j)); }
t_はいつ供給されてるのかな
MulAdd ma(bp_, x->second, x->first->get_bp());
bp_は参照で渡しているから、構造体に入れて上のコードが実行されるたびに編集される。
bp_が事後確率行列であることを理解した。


transBP_centroidfold_ractip(BPTable bp_centroid, std::vector<float>& bp_ractip, std::vector<int>& offset)
を実装する。
bp_の中身はbp_(i,j)でアクセス可能っぽい<-どこに書いてあるんだろう

もとのbpの形式:
BPTable bp_;
BPTable: 
typedef BPTableTmpl<float> BPTable;
BPTableTmpl<V>:
bp.hに書いてある
BPTableTmpl<float>を理解する。bp(i.j)でなんで要素を呼べるんだー

typedef BPTableTmpl<float> BPTable;
BPTableTmpl<float>に演算子が定義されている。
T operator()(uint i, uint j) const { return bp_(i,j); }
CYKTable<T> bp_;
CYKTable<T>にも演算子が定義されている。

  inline
  const T& operator()(uint i, uint j) const
  {
    return get(i,j);
  }
// const宣言を理解する  
inline
T& get(uint i, uint j)
{
  assert(i<=j);
  assert(ptr_[i]!=NULL);
  return ptr_[i][j];
}
#include <cassert>:一致判断関数
ptr_:  std::vector<T*> ptr_;

      for (uint i=0; i!=size_; ++i)
        ptr_[i] = &table_[size_*(size_+1)/2 - (size_-i)*(size_-i+1)/2 - i];
    } else {
      for (uint i=0; i!=size_; ++i)
        ptr_[i] = &table_[i*max_dist_-i];
    }	
// table_ と size_ わからない

setupはいつよばれるのか: resizeのとき
std::vector<T> table_;

bp_(i,j)でよびだされているとしか思えないけどなぁ。。。それで実装してみるか。
//!!!! CAUTION !!!! bp_(i,j)の正当性を理解していません！！！！！///////

void RactIP::
transBP_centroidfold_ractip(BPTable bp_centroidfold, VF& bp, VI& offset)

まず上三角行列だけを取り出して、一次元配列にしていく。
offsetは行列の大きさからただちに計算される。
offset計算関数はComputeROwOffsetによって計算する。
InferenceEngineのコードが参考になりそうなので閲覧する。
template<class RealT>
int InferenceEngine<RealT>::ComputeRowOffset(int i, int N, int w /*=0*/) const
{
    Assert(i >= 0 && i <= N, "Index out-of-bounds.");
#define USE_EFFICIENT_WINDOW
#ifdef USE_EFFICIENT_WINDOW
    if (w==0)
    {
	// equivalent to:
	//   return N*(N+1)/2 - (N-i)*(N-i+1)/2 - i;
	return i*(N+N-i-1)/2;
    }
    else
    {
	return i*w - i;
    }
#else
    // equivalent to:
    //   return N*(N+1)/2 - (N-i)*(N-i+1)/2 - i;
    return i*(N+N-i-1)/2;
#endif
}

必要なのは、N
    // compute indexing scheme for upper triangular arrays;
    // also allow each position to be unpaired by default, and
    // set the loss for each unpaired position to zero
    for (int i = 0; i <= L; i++)
    {
      offset[i] = ComputeRowOffset(i,L+1,max_bp_dist);//(only here CRO)
        allow_unpaired_position[i] = 1;
        loss_unpaired_position[i] = RealT(0);
    }

enはこのあとまだ使われるのか。（メンバを用いることがあれば、問題になるかもしれない）
->使わない。心配はいりません。

まず、上三角行列をとりだすことから。
bp(i,j)と(j,i)
は等しいんだろうか？
それともそもそもその座標には一回もアクセスしていなんだろうか。
・・ふつうに入っていると仮定する。
上三角の値が右上行列に入っていると仮定する。

一次元配列を取り出した。
    max_bp_dist(max_bp_dist),//contrafoldではこの引数は与えられないのでデフォルト値となる
    InferenceEngine(bool allow_noncomplementary, int max_bp_dist=0);

trans関数の実装を終了した.
二次構造での塩基対確率の実装を終了した。
----------------------------------------------
残り
・MakeFileの作成
・rnaduplex_alnの実装
----------------------------------------------
・rnaduplex_alnの実装
Alnから配列を引き抜く関数
VVF& hpの各塩基に対する平均確率の取り方を考える。
seq()でlist<string>を得る

rnaduplex_alnを実装した。
---------------------------------------------
MakeFileの作成
automakeを用いている
環境依存の変数をコンパイラに渡すのに、autoconfを使う。
automakeとは何か:

-----------------------------------------------
makeの前に、単体でコンパイルが通るようにデバッグする。
---------
私が手を付けていないところで出るエラーは、./configureしていないことによってマクロ変数が代入されていないことが原因になっているものですべてではないかと思う。
今は私が手を付けたところだけを修正する。
---------
alifoldのところ、vmを通じて引数に接続する文がまだたくさんのこっているので、
ひとまずそこをすべてコメントアウトする。
iteratorの文法間違いを起こしているようなので、イテレータの仕様を読んで、書き直す。
------------
s1まわりのiterator 文法間違い
s1は参照であるから、この中身に対するイテレータを生成しようとしているが、それは生成されない。
右辺にあるものの正確な型を理解しよう。clangのエラーメッセージの理解もしよう。
------------
mix_weightのちゃんとした実装
(gengetoptのggoファイルの実装)
などの入出力の整備
複数オプション：(mix_weightのため)
複数オプションを廃止する。そもそもwと1-wなんだから、要求するほうがおかしい。
片方だけを頂いて、もう片方はデフォルトで1-wとする。
cmdline1.c .hのPACKAGEマクロ変数のエラーは、config.hがまだ生成されていないために起こるエラー。
佐藤さんのggoファイルがあった。。。ショック。
------------
vmの書き換え
-----------
solve関数の引数型の指定でエラー
constの理解をする。右左どちらを修飾するのか。

undeclaredってでてくるの、ヘッダに書かれていないことが原因か？
------
modelsのメンバ関数を呼び出すようにしているけど、これはmodelsの型を間違えている。
違う型で宣言しなきゃいけない。
centroid_alifoldではMixtureModelのインスタンスに対して呼び出しをしていた。
修正した。渡す引数をmodelsからcfに変更した。
------
ComputeRowOffset関数は、InferenceEngineに入っている。そのため、InferenceEngineを呼びださなければならない。
public memberにして、InferenceEngine(false) en;としてenからcallした
------
ソースファイルの変更をターミナルが反映しない。ターミナルの設定を変更するにはどうすればいいんだろう。
わからなかった。明日友達に聞こう。
------
include先でエラーになっている場合、下の出力のnoteメッセージに自分のソースコードがないか調べる
それが問題のことが多い、下に行くほど原因らしい
------
まだまだ順番に読んでいく。3時になったら工学部の方を始める。
ractip.cpp:526:32: note: in instantiation of template class 'std::__1::list<std::__1::basic_string<char> &, std::__1::allocator<std::__1::basic_string<char> &> >' requested here
solve(std::list<std::string& > s1, std::list<std::string& > s2, std::string& r1, std::string& r2, MixtureModel<Aln> cf)
listのインスタンス化が必要
引数の型を変更したい。aln.seq()の型を確認する。
 const std::list<std::string>& seq() const { return seq_; }
変更した。
------
 std::string s1(fa1.seq());
下流、ractIPの表示時に上の処理を行っている、ここを変更する
the energy of the joint structureを計算・表示するのに配列が必要とされる。
この部分はまだまったくソースを読んでいないのですが、配列が必要ならその塩基配列を塩基配列アラインメントに
置き換える
表示であれば、list<string>を与えて、内部でそれをそのまま表示する関数に変更する。
この機能は私の卒業論文には含めないことができるので、卒業論文を書いてから実装する。
------
  cf.calculate_posterior(seq);
calculate_posteriorの引数の型はAln
Alnを入れる
solve関数からすべてAlnを引数にとるように変更する。
内部でlist<string>が必要ならコールする
変更した。
------
ractip.cpp:228:3: error: member function 'transBP_centroidfold_ractip' not viable: 'this' argument has type 'const RactIP', but function is not marked const
  transBP_centroidfold_ractip(bp_centroidfold, bp, offset);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alifoldはRactIPに対してconstメンバ関数
中でtransBPを読んでいて、これはconstでないため
transBPをconstに修正した
------
eaの修正をした
------
ractip.cpp:1198:38: error: no viable conversion from 'FoldingEngine<Aln> *' to 'MixtureModel<Aln>'
  float ea = solve(fa1, fa2, r1, r2, cf);
                                     ^~
./centroidalifold/engine/mixture.h:30:7: note: candidate constructor (the implicit copy constructor) not viable: no known conversion from 'FoldingEngine<Aln> *' to 'const MixtureModel<Aln> &'
      for 1st argument
class MixtureModel : public FoldingEngine<SEQ>
      ^
./centroidalifold/engine/mixture.h:33:3: note: candidate constructor not viable: no known conversion from 'FoldingEngine<Aln> *' to
      'const std::vector<std::pair<FoldingEngine<Aln> *, float> > &' for 1st argument
  MixtureModel(const std::vector<std::pair<FoldingEngine<SEQ>*,float> >& models, bool run_as_mea=false);
  ^
ractip.cpp:526:77: note: passing argument to parameter 'cf' here
solve(Aln& s1, Aln& s2, std::string& r1, std::string& r2, MixtureModel<Aln> cf)
                                                                            ^
cfの型が引数型と異る
宣言を修正した
------
ractip.cpp:544:15: error: no viable conversion from 'Aln' to 'const std::string' (aka 'const basic_string<char, char_traits<char>, allocator<char> >')
    rnaduplex(s1,s2,hp);// 1st structure base pairing probability
              ^~
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/c++/v1/string:1185:5: note: candidate constructor not viable: no known conversion from 'Aln' to
      'const std::__1::basic_string<char> &' for 1st argument
    basic_string(const basic_string& __str);
    ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/c++/v1/string:1194:31: note: candidate constructor not viable: no known conversion from 'Aln' to
      'const_pointer' (aka 'const char *') for 1st argument
    _LIBCPP_INLINE_VISIBILITY basic_string(const_pointer __s);
                              ^
ractip.cpp:433:30: note: passing argument to parameter 's1' here
rnaduplex(const std::string& s1, const std::string& s2, VVF& hp) const
                             ^
rnaduplexの型の問題
普通にseqで渡すように変更した。(名前をへんこうして、引数をa1とa2とした)
-------
C++は型による条件分岐がしにくいな
Haskellだったら非常にやりやすいのに
templateにしても、やることを変えることはできない
新しい関数を定義していたので、それを利用する形に変更した
-------
上と同様の問題
専門化していないために怒られている
一時的にコメントアウトするか、新しい関数に分離するか
新しい関数に分離するためには、呼び出し側で分岐が必要。
(c++ならautoで書けるんだっけ、それでもいい気がしてきた。)
呼び出し側で分岐する形に変更する。
solveとsolve_alnに分ける。それによって、solveまでの混流問題は解決する。バグカウント10程度。

難しい(長いだけ)
まずはコメントアウトで要らない機能を潰す。
分岐方法は実装後に考えればよい。
前処理を別の関数に分離して作る方法を思いついた
---
とりあえず、併用アプリケーションとしてではなく、独立アプリケーションとして開発する。
それによって、純粋に使用したい機能を担う文のバグだけに集中できる。
---
出力を修正
イテレータを取り出して、アラインメントに含まれる配列名と配列を全表示する　
Aln::
  const std::list<std::string>& name() const { return name_; }
  const std::list<std::string>& seq() const { return seq_; }
である
参照返しでは、ちゃんと型として参照で宣言しなければいけないのだろうか、
自動的に参照の中身をいれてくれるということはないだろうか
上の処理を解決するものとして、const_iteratorがあったのでそれを使用して、修正した。
---
---
makeをします
既知の問題点は、configureで解消されると思われるが、実際のところはわからないので、気に留めておきます。
complile
分割コンパイルしたあと、どのようにオブジェクトファイルをリンクするのかを理解する
おそらくractip.oのコンパイルコマンドを変更しなければいけないだろう
automakeが勝手にやってくれるのかもしれない。automakeのMakeFile.amの書き方を知っておく。
---
autotoolsの使い方
Makefile.am
configure.ac
------
これからやること：
---
Makefile.amを理解して、書き直す
configure.acを理解して、書き直す
centroidalifoldのふくめかたを考える
---
順番にコンパイルエラーの原因を理解する
---
Undefined symbols for architecture x86_64:
  "MixtureModel<Aln>::calculate_posterior(Aln const&)", referenced from:
      RactIP::alifold(Aln const&, std::__1::vector<float, std::__1::allocator<float> >&, std::__1::vector<int, std::__1::allocator<int> >&, std::__1::vector<std::__1::vector<float, std::__1::allocator<float> >, std::__1::allocator<std::__1::vector<float, std::__1::allocator<float> > > >&, MixtureModel<Aln>) const in ractip.o
      vtable for MixtureModel<Aln> in ractip.o
---
現在のconfigure.acを読んで理解する
centroidalifoldのmainとかと干渉しそうである。表に書いて整理して、いらないものを消す。
-----
コンパイルは、順番にリンクしていけばよい。cppファイルは個別にコンパイルしておいて、最後にリンクする。
結局一つのプログラムを作るということ
重複定義とか、相互定義とかがあってはいけない
centroidalifold内の依存関係をチェックしなければいけない。
---
./configureでできたconfigファイルで、もうエラーは起きないはず
---
makeのエラー表示読みにくいけど、ｋれはどういう仕様で決まっているのだろう
リンクの失敗を解消する
---
clang++  -g -O2  -L/usr/local/Cellar/viennarna/2.1.5//lib  -o ractip ractip.o ip.o fa.o boltzmann_param.o cmdline.o pf_duplex.o ushuffle.o SStruct.o Utilities.o  -lRNA -lglpk -lltdl -ldl -lz -lpthread 

  "MixtureModel<Aln>::calculate_posterior(Aln const&)", referenced from:
      RactIP::alifold(Aln const&, std::__1::vector<float, std::__1::allocator<float> >&, std::__1::vector<int, std::__1::allocator<int> >&, std::__1::vector<std::__1::vector<float, std::__1::allocator<float> >, std::__1::allocator<std::__1::vector<float, std::__1::allocator<float> > > >&, MixtureModel<Aln>) const in ractip.o
---
コンパイル命令に、一緒にリンクする関数が足りなくなってる。
修正しよう。
MakeFileの構文を理解したら、automakeでどのように書けばいいか調べて、書く。
それで動くはず。
---
configureに渡すviennaRNAのパスを変更する
---
書くのはconfigure.acとMakefile.am
---
リンクを変えればいいだけ、
あんまり難しく考えることはありません
---
centroidalifold内のMakefile.amのなかの実行プログラム作成命令文を削除して、コンパイルだけするようにする
リンクは最後にまとめて行う為
---
	util.h\
	fa.cpp fa.h 
	contrafold/contrafold.h \
        probconsRNA/probcons.h \
	contralign/contralign.h \
        naview.c \
	engine/boltzmann_param.h engine/boltzmann_param.c
(nokori)
---
linkまできた
viennaRNAのパス
contrafold.oのなかでリンクに失敗した

<contrafold>
となっているところかな?centroidalifoldでのソースを確認してみよう。
---
contrafoldのクラス定義のパスが通らない
ifndefで落ちているのかもしれない
ifndefは違った
contrafold/contrafold.hで宣言されている関数の実装を探している
---
contrafold/contrafold.hをincludeしているファイルを全探索する
見つからない。centroidalifoldでどのようになっているか見てみよう。
contrafold.rbが何をしているか調べる
contrafold.rbはただのコマンドライン
linuxでやってみよう。原因不明
centroidalifoldではwrapper.cppでくるまれている
---
grepで探しても見つからない、どこにあるんだ
継承しているものを確認
CONTRAfoldModel:FoldingEngine<std::string>を継承している
FoldingEngineにそんなのない
wrapper.cppだった。できたー
---
duplicatesymbol
7回
どういうことか
ParameterManagerが怪しいうん。違うね。ParameterGroupでした。
InferenceEngine.ippか、Default.ippか
どちらも修正した(ifndef慣用句を挿入した)
治らない
wrapperを使う前、まだ何も起こらなかった
wrapperが原因なのはあきらか
エラー表示の読み方を理解する
サンプルを作って実験してみよう
---
いきなりリンクが効かなくなった
g++を一回走らせただけなのに
InferenceEngine.ippのリンクガードを解除したらこのエラーは起きなくなった
^
そうじゃない。clangではエラーが出ないけど、g++-4.8だと出ている
でもこれはリンクエラーなので本質的でない
---
ヘッダファイルの中身はすべてリンクガードを貼った
wrapper.oをincludeするときにractipと干渉したということ
ractip.cppのmain関数を探索しよう
mainはコードの量が少なかった
wrapperを呼び出すときに、二重定義がおこっている可能性を考えよう
wrapperのスコープで、一番外側にあるものは
最後のインスタンス化を除きすべてスコープが制限されている。
最後のインスタンス化について考える
---
wrapperしかincludeしていないファイルと、ractipしかincludeしていないファイルの名前衝突の可能性
